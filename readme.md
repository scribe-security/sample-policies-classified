# Sample Policies

This repo includes samples of policy configuraions for Scribe's ```valint``` tool.

## Policy Catalog

### SDLC Governance Policies

|Category|Policy|Description|
|----------|---------------------------|----------------|
|SDLC Governance|[Coding Permissions](#coding-permissions)|Control file modifications by authorized identities.|
|SDLC Governance|Merging Permissions|Ensure authorized identities merge to main.|
|SDLC Governance|[Forbid Unsigned Commits](#forbid-unsigned-commits)|Prevent unsigned commits in evidence.|
|SDLC Governance|[Forbid Commits To Main](#forbid-commits-to-main)|Verify there were no commits to the main branch.|
|SDLC Governance|[Banned Builder Dependencies](#banned-builder-dependencies)|Restrict banned builder dependencies.|
|SDLC Governance|[Verify Build Time](#build-time)|Validate build time within window.|
|SDLC Governance, GRC|[Verify Byproducts Produced](#produced-byproducts)|Ensure that specific byproducts are produced.|
|SDLC Governance|[No Critical CVEs](#no-critical-cves)|Prohibit ANY critical CVEs.|
|SDLC Governance|[Limit High CVEs](#limit-high-cves)|Limit high CVEs.|
|SDLC Governance|[Do Not Allow Specific CVEs](#do-not-allow-specific-cves)|Prevent specific CVEs in the artifact.|
|SDLC Governance|[No Static Analysis Errors](#no-static-analysis-errors)|Prevent static analysis errors in the artifact.|
|SDLC Governance|[Limit Static Analysis Warnings](#limit-static-analysis-warnings)|Restrict static analysis warnings count.|
|SDLC Governance|[Do Not Allow Specific Static Analysis Rules](#do-not-allow-specific-static-analysis-rules)|Restrict specific static analysis warnings.|
|SDLC Governance|[Do Not Allow Vulnerabilities Based On Specific Attack Vector](#do-not-allow-vulnerabilities-based-on-specific-attack-vector)|Restrict vulnerabilities based on specific attack vector.|
|SDLC Governance|[Report IaC Configuration errors](#report-iac-configuration-errors)|Check if there are any IaC configuration errors.|
|SDLC Governance|[Verify Semgrep SARIF report](#verify-semgrep-sarif-report)|Check for specific violations in a semgrep report.|
|SDLC Governance|[Forbid Accessing Host](#forbid-accessing-host)|Do not allow images with detected vulnerabilities giving access to the host system.|
|SDLC Governance|No Package Downgrading|Restrict package downgrades.|
|SDLC Governance|Verify Source code Integrity|Verify that the artifact source code has not been modified|
|SDLC Governance|Verify Dependencies Integrity|Verify that specific files or folders have not been modified|
|SDLC Governance, GRC|[Verify Byproducts Produced](#produced-byproducts)|Ensure that specific byproducts are produced.|

### SLSA Policies

|Category|Policy|Description|
|----------|---------------------------|----------------|
|SLSA|[Provenance Available](#slsa)|No provenance found.|
|SLSA|[Source History Verified](#slsa)|Branch main protections rules should require signed commits.|
|SLSA|[Source Retained Indefinitely](#slsa)|Branch main protections rules should disallow deletions.|
|SLSA|[Build Scripted](#slsa)|The build is scripted .github/workflows/main.yml.|
|SLSA|[Source Version Controlled](#slsa)|The code is managed in this here.|
|SLSA|[Build Service](#slsa)|The build is executed by a service 'GitHub Actions'.|
|SLSA|[Provenance Authenticated](#slsa)|The provenance is authenticated with this a.sig.|
|SLSA|[Provenance Service Generated](#slsa)|The provenance is generated by the build system.|
|SLSA|[Build As Code](#slsa)|The build is defined and configured as code .github/workflows/main.yml.|
|SLSA|[Build Ephemeral Environment](#slsa)|The build is run in an ephemeral environment on GitHub-hosted runners.|
|SLSA|[Build Isolated](#slsa)|Scribe determined that the build environment is isolated.|
|SLSA|[Provenance Non Falsifiable](#slsa)|Provenance cannot be falsified by the build service’s users. Default checks were performed.|

### NIST SSDF Policies

|Category|Policy|Description|
|----------|---------------------------|----------------|
|NIST SSDF|[Ensure inactive branches are reviewed and removed periodically](#slsa)|For each code repository in use, review existing Git branches and remove those which have not been active for a prescribed period of time.|
|NIST SSDF|[Ensure repository creation is limited to specific members](#slsa)|Restrict repository creation to trusted users and teams only.|
|NIST SSDF|[Ensure inactive users are reviewed and removed periodically](#slsa)|For each repository in use, review inactive user accounts (members that left the organization, etc.) and remove them.|
|NIST SSDF|[Ensure an organization ’ s identity is confirmed with a Verified badge](#slsa)|Verify the organization"s domains and secure a "Verified" badge next to its name.|
|NIST SSDF|[Ensure all build steps are defined as code](#slsa)|Convert pipeline instructions into code-based syntax, and upload them to the organization"s version control platform.|
|NIST SSDF|[Ensure pipelines are automatically scanned for vulnerabilities](#slsa)|For each pipeline, set automated vulnerabilities scanning.|
|NIST SSDF|[Ensure scanners are in place to identify and prevent sensitive data in pipeline files](#slsa)|For every pipeline that is in use, set scanners that will identify and prevent sensitive data in it.|
|NIST SSDF|[Ensure all external dependencies used in the build process are locked](#slsa)|For every external dependency in use in pipelines, lock it.|
|NIST SSDF|[Ensure dependencies are pinned to a specific , verified version](#slsa)|For every dependency in use, pin to a specific version.|
|NIST SSDF|[Ensure packages are automatically scanned for known vulnerabilities](#slsa)|Set automatic scanning of packages for vulnerabilities.|
|NIST SSDF|[Ensure packages are automatically scanned for license implications](#slsa)|Set automatic package scanning for license implications.|
|NIST SSDF|[Ensure any change to code receives approval of two strongly authenticated users](#slsa)|An organization can protect specific code branches — for example, the "main" branch which often is the version deployed to production — by setting protection rules. These rules secure your code repository from unwanted or unauthorized changes. You may set requirements for any code change to that branch, and thus specify a minimum number of reviewers required to approve a change.|
|NIST SSDF|[Ensure previous approvals are dismissed when updates are introduced to a code change proposal](#slsa)|For each code repository in use, enforce an organization-wide policy to dismiss given approvals to code change suggestions if those suggestions were updated.|
|NIST SSDF|[Ensure that there are restrictions on who can dismiss code change reviews](#slsa)|For each code repository in use, carefully select the individual collaborators or groups whom you trust with the ability to dismiss code change reviews.|
|NIST SSDF|[Ensure code owners are set for extra sensitive code or configuration](#slsa)|For every code repository in use, identify particularly sensitive parts of code and configurations and set trusted users to be their code owners.|
|NIST SSDF|[Ensure all checks have passed before the merge of new code](#slsa)|Configure each code repository to require all status checks to pass before permitting a merge of new code.|
|NIST SSDF|[Ensure open git branches are up to date before they can be merged into codebase](#slsa)|For each code repository in use, enforce a policy to only allow merging open branches if they are current with the latest change from their origin repository.|
|NIST SSDF|[Ensure all open comments are resolved before allowing to merge code changes](#slsa)|For each code repository in use, require open comments to be resolved before the relevant code change can be merged.|
|NIST SSDF|[Ensure verifying signed commits of new changes before merging](#slsa)|For each repository in use, enforce the branch protection rule of requiring signed commits, and make sure only signed commits are capable of merging.|
|NIST SSDF|[Ensure linear history is required](#slsa)|For each repository in use, require linear history and/or allow only rebase merge and squash merge.|
|NIST SSDF|[Ensure branch protection rules are enforced on administrators](#slsa)|For each repository in use, enforce branch protection rules on administrators, as well.|
|NIST SSDF|[Ensure pushing of new code is restricted to specific individuals or teams](#slsa)|For each repository in use, allow only trusted and responsible users to push or merge new code.|
|NIST SSDF|[Ensure force pushes code to branches is denied](#slsa)|For each repository in use, block the option to "Force Push" code.|
|NIST SSDF|[Ensure branch deletions are denied](#slsa)|For each repository that is being used, block the option to delete protected branches via branch protection rules.|
|NIST SSDF|[Ensure minimum admins are set for the organization](#slsa)|Set the minimum number of administrators in your organization.|
|NIST SSDF|[Ensure the organization is requiring members to use MFA](#slsa)|Use the built-in setting to set the enforcement of Multi-Factor Authentication for each member of the organization.|
|NIST SSDF|[Ensure 2 admins are set for each repository](#slsa)|For every repository in use, set two administrators.|
|NIST SSDF|[Ensure strict base permissions are set for repositories](#slsa)|Set strict base permissions for the organization repositories — either "None" or "Read."|
|NIST SSDF|[Ensure access to the build process ’ s triggering is minimized](#slsa)|For every pipeline in use, grant only the necessary members permission to trigger it.|
|NIST SSDF|[Ensure user ’ s access to the package registry utilizes MFA](#slsa)|For each package registry in use, enforce Multi-Factor Authentication as the only way to authenticate.|
|NIST SSDF|[Ensure webhooks of the package registry are secured](#slsa)|For each webhook in use, change it to secured (over HTTPS).|
|NIST SSDF|[Ensure all public repositories contain a SECURITY . md file](#slsa)|For each repository in use, create a SECURITY.md file and save it in the documents or root directory of the repository.|
|NIST SSDF|[Ensure repository deletion is limited to specific members](#slsa)|Enforce repository deletion by a few trusted and responsible users only.|
|NIST SSDF|[Ensure issue deletion is limited to specific members](#slsa)|Restrict issue deletion to a few trusted and responsible users only.|
|NIST SSDF|[Ensure pipeline steps produce an SBOM](#slsa)|For each pipeline, configure it to produce an SBOM on every run.|
|NIST SSDF|[Ensure anonymous access to artifacts is revoked](#slsa)|Disable the anonymous access option on every artifact or package manager in use.|

### GRC Policies

|Category|Policy|Description|
|----------|---------------------------|----------------|
|GRC|[Required Packages](#slsa)|Ensure mandatory packages/files in the artifact.|
|GRC|[Banned Licenses](#slsa)|Restrict inclusion of certain licenses in the artifact.|
|GRC|[Complete Licenses](#slsa)|Guarantee all packages have valid licenses.|
|GRC|[No License Modification](#slsa)|Prevent license modifications.|
|SLSA, SSDF|[Forbid Unsigned Artifacts](#slsa)|Verify the artifact's authenticity and signer identity.|
|GRC, SSDF|[Blocklist Packages](#slsa)|Prevent risky packages in the artifact.|
|GRC, SSDF|[Fresh Artifact](#slsa)|Verify an artifact's freshness.|
|GRC, SSDF|[Fresh Image](#slsa)|Ensure an image freshness.|
|GRC, SLSA, SSDF|[Verify Image Lables/Annotations](#slsa)|Ensure image has required labels (e.g., git-commit).|
### General Information

Most of the policies in this repo consist of two files: a `.yaml` and a `.rego`.

The first is a part of `valint` configuration file and needs to be merged to the actual `valint.yaml` or used separately if default `valint` config is sufficient.  
The second is a rego file that contains the actual policy code. It can be used as is or merged to the `.yaml` file by quoting its content under `rego.script` parameter instead of using the `rego.file` one.

### SBOMs

An example of creating an SBOM evidence:

```bash
valint bom ubuntu:latest -o statement-cyclonedx-json
```

To verify the evidence against the policy call:

```bash
valint verify ubuntu:latest -i statement-cyclonedx-json -c <policyname>.yaml
```

An example of creating signed SBOM attestation:

```bash
valint bom ubuntu:latest -o attest
```

To verify the attestation against the policy call:

```bash
valint verify ubuntu:latest -i attest -c <policyname>.yaml
```

#### Forbid Unsigned Artifacts

This policy ([artifact-signed.yaml](policies/sboms/artifact-signed.yaml)) verifies that the SBOM is signed and the signer identity equals to a given value.

If you have not created an SBOM yet, create an sbom attestation, for example:

In [artifact-signed.yaml](policies/sboms/artifact-signed.yaml) file,
edit policy parameters ```attest.cocosign.policies.modules.input identity``` to reflect the expected signers identity.

You can also edit `target_type` to refelct the artifact type.

> Optional target types are `git`,`directory`, `image`, `file`, `generic`.

```yaml
identity:
  emails:
    - example@company.com
match:
   target_type: image
```

#### Blocklist Packages

This policy ([blocklist-packages.yaml](policies/sboms/blocklist-packages.yaml), [blocklist-packages.rego](policies/sboms/blocklist-packages.rego)) verifies an SBOM does not include packages in the list of risky packages.

`rego` code for this policy can be found in the [blocklist-packages.rego](policies/sboms/blocklist-packages.rego) file.

Edit the list of the risky licenses in the `input.rego.args` parameter in file [blocklist-packages.yaml](policies/sboms/blocklist-packages.yaml):

```yaml
args:
   blocklist: 
      - "pkg:deb/ubuntu/tar@1.34+dfsg-1ubuntu0.1.22.04.1?arch=arm64&distro=ubuntu-22.04"
      - "log4j"
   blocklisted_limit: 0
```

#### Required Packages

This policy ([required-packages.yaml](policies/sboms/required-packages.yaml), [required-packages.rego](policies/sboms/required-packages.rego)) verifies that the SBOM includes packages from the list of required packages.

Edit the list of the required packages in the `input.rego.args` parameter in file [required-packages.yaml](policies/sboms/required-packages.yaml):

```yaml
args:
   required_pkgs:
      - "pkg:deb/ubuntu/bash@5.1-6ubuntu1?arch=amd64\u0026distro=ubuntu-22.04"
   violations_limit: 1
```

The policy checks if there is a package listed in SBOM whose name contains the name of a required package as a substring. For example, if the package name is ```pkg:deb/ubuntu/bash@5.1-6ubuntu1?arch=amd64\u0026distro=ubuntu-22.04```, it will match any substring, like just ```bash``` or ```bash@5.1-6ubuntu1```.

#### Banned Licenses

This policy ([banned-licenses.yaml](policies/sboms/banned-licenses.yaml), [banned-licenses.rego](policies/sboms/banned-licenses.rego)) verifies that the SBOM does not include licenses from the list of risky licenses.

Edit the list of the risky licenses in the `input.rego.args` parameter in file [banned-licenses.yaml](policies/sboms/banned-licenses.yaml):

```yaml
rgs:
   blocklist: 
      - GPL
      - MPL
   blocklisted_limit : 10
```

#### Complete Licenses

This policy ([complete-licenses.yaml](policies/sboms/complete-licenses.yaml), [complete-licenses.rego](policies/sboms/complete-licenses.rego)) verifies that every package in the SBOM has a license.

It doesn't have any additional parameters.

#### Fresh Artifact

This policy ([fresh-sbom.yaml](policies/sboms/fresh-sbom.yaml), [fresh-sbom.rego](policies/sboms/fresh-sbom.rego)) verifies that the SBOM is not older than a given number of days.

Edit the policy in the `input.rego.args` parameter in file [fresh-sbom.yaml](policies/sboms/fresh-sbom.yaml):

```yaml
args:
   max_days : 30
```

### Images

An example of creating an evidence:

```bash
valint bom ubuntu:latest -o statement
```

To verify the evidence against the policy:

```bash
valint verify ubuntu:latest -i statement -c <policyname>.yaml
```

#### Restrict Shell Image Entrypoint

This policy ([restrict-shell-entrypoint.yaml](policies/images/restrict-shell-entrypoint.yaml), [restrict-shell-entrypoint.rego](policies/images/restrict-shell-entrypoint.rego)) verifies that the image entrypoint does not provide shell access by default. It does so by verifying that both `Entrypoint` and `Cmd` don't contain `sh` (there's an exclusion for `.sh` though).

This policy is not configurable.

#### Blocklist Image Build Scripts

This policy ([blocklist-build-scripts.yaml](policies/images/blocklist-build-scripts.yaml), [blocklist-build-scripts.rego](policies/images/blocklist-build-scripts.rego)) verifies that the image did not run blocklisted scripts on build.

Edit the list of the blocklisted scripts in the `input.rego.args` parameter in file [blocklist-build-scripts.yaml](policies/images/no-build-scripts.yaml):

```yaml
args:
   blocklist: 
      - curl
```

#### Verify Image Lables/Annotations

This policy ([verify-labels.yaml](policies/images/verify-labels.yaml), [verify-labels.rego](policies/images/verify-labels.rego)) verifies that image has labels with required values.

Edit the list of the required labels in the config object in file [verify-labels.yaml](policies/images/verify-labels.yaml):

```yaml
args:
   labels:
      - label: "org.opencontainers.image.version"
        value: "22.04"
```

#### Fresh Image

This policy ([fresh-image.yaml](policies/images/fresh-image.yaml), [fresh-image.rego](policies/images/fresh-image.rego)) verifies that the image is not older than a given number of days.

Edit the policy in the `input.rego.args` parameter in file [fresh-image.yaml](policies/images/fresh-image.yaml):

```yaml
args:
   max_days: 183
```

#### Forbid Large Images

This policy ([forbid-large-images.yaml](policies/images/forbid-large-images.yaml), [forbid-large-images.rego](policies/images/forbid-large-images.rego)) verifies that the image is not larger than a given size.

Set max size in bytes in the `input.rego.args` parameter in file [forbid-large-images.yaml](policies/images/forbid-large-images.yaml):

```yaml
args:
   max_size: 77808811
```

### Git

An example of creating a Git evidence:

```bash
valint bom git:https://github.com/golang/go -o statement
```

To verify the evidence against the policy:

```bash
valint verify git:https://github.com/golang/go -i statement -c <policyname>.yaml
```

#### Coding Permissions

This policy ([coding-permissions.yaml](policies/git/coding-permissions.yaml), [coding-permissions.rego](policies/git/coding-permissions.rego)) verifies that files from the specified list were modified by authorized users only.

For this policy be able to run, the evidence must include a reference to the files that were modified in the commit. This can be done by adding parameter `--components commits,files` to the `valint bom` command.

For specifying the list of files and identities, edit the `input.rego.args` parameter in file [coding-permissions.yaml](policies/git/coding-permissions.yaml).
This example for repository [Golang Build](https://github.com/golang/build) verifies that files `build.go` and `internal/https/README.md` were modified only by identities containing `@golang.com` and `@golang.org`:

```yaml
args:
   ids:
      - "@golang.com"
      - "@golang.org"
   files:
      - "a.txt"
      - "somedir/b.txt"
```

#### Forbid Unsigned Commits

This policy ([no-unsigned-commits.yaml](policies/git/no-unsigned-commits.yaml), [no-unsigned-commits.rego](policies/git/no-unsigned-commits.rego)) verifies that evidence has no unsigned commits. It does not verify the signatures though.

#### Forbid Commits To Main

This policy ([no-commit-to-main.yaml](policies/git/no-commit-to-main.yaml), [no-commit-to-main.rego](policies/git/no-commit-to-main.rego)) verifies that evidence has no commits made to main branch.

### SLSA

Example of creating a SLSA statement:

```bash
valint slsa ubuntu:latest -o statement
```

Example of verifying a SLSA statement:

```bash
valint verify ubuntu:latest -i statement-slsa -c <policyname>.yaml
```

#### Builder Name

This policy ([verify-builder.yaml](policies/slsa/verify-builder.yaml), [verify-builder.rego](policies/slsa/verify-builder.rego)) verifies that the builder name of the SLSA statement equals to a given value.

Edit policy parameters in the `input.rego.args` parameter in file [verify-builder.yaml](policies/slsa/verify-builder.yaml):

```yaml
args:
   id: "local"
```

#### Banned Builder Dependencies

This policy ([banned-builder-deps.yaml](policies/slsa/banned-builder-deps.yaml), [banned-builder-deps.rego](policies/slsa/banned-builder-deps.rego)) verifies that the builder used to build an artifact does not have banned dependencies (such as an old openSSL version).

Edit policy parameters in the `input.rego.args` parameter in file [banned-builder-deps.yaml](policies/slsa/banned-builder-deps.yaml):

```yaml
args:
   blocklist:
      - name: "valint"
         version: "0.0.0"
```

#### Build Time

This policy ([build-time.yaml](policies/slsa/build-time.yaml), [build-time.rego](policies/slsa/build-time.rego)) verifies that the build time of the SLSA statement is within a given time window The timezone is derived from the timestamp in the statement.

Edit policy parameters in the `input.rego.args` parameter in file [build-time.yaml](policies/slsa/build-time.yaml):

```yaml
args:
   start_hour: 8
   end_hour: 20
   workdays:
      - "Sunday"
      - "Monday"
      - "Tuesday"
      - "Wednesday"
      - "Thursday"
```

#### Produced Byproducts

This policy ([verify-byproducts.yaml](policies/slsa/verify-byproducts.yaml), [verify-byproducts.rego](policies/slsa/verify-byproducts.rego)) verifies that the SLSA statement contains all the required byproducts.
According to the SLSA Provenance [documentation](https://slsa.dev/spec/v1.0/provenance), there are no mandatory fields in the description of a byproduct, but at least one of `uri, digest, content` should be specified.
So, the policy checks if each byproduct specified in the policy configuration is present in one of those fields of any byproduct in the SLSA statement. It does so by calling the `contains` function, so the match is not exact.

Before running the policy, specify desired byproducts in the `input.rego.args` parameter in file [verify-byproducts.yaml](policies/slsa/verify-byproducts.yaml):

```yaml
args:
   byproducts:
      - 4693057ce2364720d39e57e85a5b8e0bd9ac3573716237736d6470ec5b7b7230
```

#### Verify That Field Exists

This policy ([field-exists.yaml](policies/slsa/field-exists.yaml), [field-exists.rego](policies/slsa/field-exists.rego)) verifies that the SLSA statement contains a field with the given path.

Before running the policy, specify desired paths in the `input.rego.args` parameter in file [field-exists.yaml](policies/slsa/field-exists.yaml):

```yaml
args:
   paths:
      - "predicate/runDetails/builder/builderDependencies"
   violations_threshold: 0
```

### Sarif Reports

#### Generic SARIF Policy

This policy ([verify-sarif.yaml](policies/sarif/verify-sarif.yaml), [verify-sarif.rego](policies/sarif/verify-sarif.rego)) allows to verify any SARIF report against a given policy. The policy has several parameters to check against:

* ruleLevel: the level of the rule, can be "error", "warning", "note", "none"
* ruleIds: the list of the rule IDs to check against
* precision: the precision of the check, can be "exact", "substring", "regex"
* ignore: the list of the rule IDs to ignore
* maxAllowed: the maximum number of violations allowed

These values can be changed in the `input.rego.args` section in the [verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file.

##### Creating a BOM out of a SARIF report

Create a trivy sarif report of the vulnerabilities of an image:

```bash
trivy image ubuntu:latest -f sarif -o ubuntu-cve.json
```

Create an evidence from this report:

```bash
valint bom ubuntu-cve.json --predicate-type http://scribesecurity.com/evidence/generic/v0.1  -o statement-generic
```

Verify the attestation against the policy:

```bash
valint verify ubuntu-cve.json -i statement-generic -c policies/sarif/verify-sarif.yaml
```

###### Running Trivy On Docker Container Rootfs

As an alternative, one can run `trivy` against an existing Docker container rootfs:

```bash
docker run --rm -it alpine:3.11
```

Then, inside docker run:

```bash
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
trivy rootfs / -f sarif -o rootfs.json
```

Then, outside docker run this to copy the report from the container:

```bash
docker cp $(docker ps -lq):/rootfs.json .
```

After that create the evidence and verify it as described above.

##### No Critical CVEs

To verify that the SARIF report does not contain any critical CVEs, set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level:
      - critical
   precision: []
   rule_ids: []
   ignore: []
   max_allowed: 0
```

##### Limit High CVEs

To verify that the SARIF report does not contain more than specified number of CVEs with high level (let's say 10), set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level: high,
   precision: []
   rule_ids: []
   ignore: []
   max_allowed: 10
```

##### Do Not Allow Specific CVEs

To verify that the SARIF report does not contain certain CVEs (let's say CVE-2021-1234 and CVE-2021-5678), set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level:
      - "error"
      - "warning"
      - "note"
      - "none"
   precision: []
   rule_ids:
      - "CVE-2021-1234"
      - "CVE-2021-5678"
   ignore: []
   max_allowed: 0
```

##### No Static Analysis Errors

To verify that the SARIF report does not contain any static analysis errors, set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level:
      - "error"
   precision: []
   rule_ids: []
   ignore: []
   max_allowed: 0
```

##### Limit Static Analysis Warnings

To verify that the SARIF report does not contain more than specified number of static analysis warnings (let's say 10), set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level:
      - "warning"
   precision: []
   rule_ids: []
   ignore: []
   max_allowed: 10
```

##### Do Not Allow Specific Static Analysis Rules

To verify that the SARIF report does not contain static analysis warnings from the following rules: "rule1", "rule2", "rule3", set the following parameters in the `rego.args` section in the[verify-sarif.yaml](policies/sarif/verify-sarif.yaml) file:

```yaml
args:
   rule_level:
      - "error"
      - "warning"
      - "note"
      - "none"
   precision: []
   rule_ids:
      - "rule1"
      - "rule2"
      - "rule3"
   ignore: []
   max_allowed: 0
```

##### Do Not Allow Vulnerabilities Based On Specific Attack Vector

Trivy/grype reports usually contain descriptions for some CVEs, like impact and attack vector.
This policy ([verify-attack-vector.yaml](policies/sarif/verify-attack-vector.yaml), [verify-attack-vector.rego](policies/sarif/verify-attack-vector.rego)) is meant to restrict number of vulnerabilities with specific attack vectors.
For example, to restrict vulnerabilities with attack vector "stack buffer overflow", set the following parameters in the `rego.args` section in the [verify-attack-vector.yaml](policies/sarif/verify-attack-vector.yaml) file:

```yaml
args:
   attack_vectors:
      - "stack buffer overflow"
   violations_threshold: 0
```

Then run the policy against the SARIF report as described above.

#### Report IaC Configuration errors

This policy ([report-iac-errors.yaml](policies/sarif/report-iac-errors.yaml), [report-iac-errors.rego](policies/sarif/report-iac-errors.rego)) allows to verify a Trivy IaC report and check if there are any errors in the configuration.

First, create a trivy report of the misconfigurations of a Dockerfile:

```bash
trivy config <dir_containing_dockerfile> -f sarif -o my-image-dockerfile.json
```

Create an evidence from this report:

```bash
valint bom my-image-dockerfile.json --predicate-type http://scribesecurity.com/evidence/generic/v0.1  -o statement-generic
```

Verify the attestation against the policy:

```bash
valint verify my-image-dockerfile.json -i statement-generic -c policies/sarif/report-iac-errors.yaml
```

The only configurable parameter in [report-iac-errors.yaml](policies/sarif/report-iac-errors.yaml) is `violations_threshold`, which is the maximum number of errors allowed in the report:

```yaml
args:
   violations_threshold: 0
```

#### Verify Semgrep SARIF report

`semgrep`, a code analysis tool, can produce SARIF reports, which later can be verified by `valint` against a given policy.

This policy ([verify-semgrep-report.yaml](policies/sarif/verify-semgrep-report.yaml), [verify-semgrep-report.rego](policies/sarif/verify-semgrep-report.rego)) allows to verify that given SARIF report does not contain specific rules violations.

First, one needs to create a semgrep report (say, for the `openvpn` repo):

```bash
cd openvpn/
semgrep scan --config auto -o semgrep-report.sarif --sarif
```

Then, create an evidence from this report:

```bash
valint bom semgrep-report.sarif --predicate-type http://scribesecurity.com/evidence/generic/v0.1  -o statement-generic
```

Configuration of this policy is done in the file [verify-semgrep-report.yaml](policies/sarif/verify-semgrep-report.yaml). In this example we forbid any violations of the `use-after-free` rule:

```yaml
args:
   rule_ids:
      - "use-after-free"
   violations_threshold: 0
```

Then, run `valint verify` as usual:

```bash
valint verify semgrep-report.sarif -i statement-generic -c policies/sarif/verify-semgrep-report.yaml
```

If any violations found, the output will contain their description, including the violated rule and the file where the violation was found.

### Forbid Accessing Host

Trivy k8s analysis can highlight some misconfigurations which allow container to access host filesystem or network. The goal of this policy is to detect such misconfigurations.

To run this policy one has to create a Trivy k8s report and create a generic statement with `valint` from it. Then, simply run the policy against this statement. No additional ocnfiguration required.

## Writing Policy Files

The rego policies can be written either as snippets in the yaml file, or as separate rego files. The advantage of using separate rego files is that one can enjoy the IDE support for rego, such as syntax highlighting and linting, and one can test the rego code more easily.

An example of such a rego file is give in the [verify-sarif.rego](policies/sarif/verify-sarif.rego) file, that is consumed by the [verify-sarif.yaml](policies/sarif/verify-sarif.yaml) configuraion file. To evaluate the policy:

```bash
valint verify ubuntu-cve.json -i statement-generic -c verify-sarif.yaml
```
